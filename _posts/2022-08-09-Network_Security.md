---
layout: post
title: Security in Computer Networks
date: 2022-08-09
categories: Computer_Network
tags: Internet
---

* TOC
{:toc}

## What is Network Security

we can identify the following desirable properties of secure communication.

* **Confidentiality**. Only the sender and intended receiver should be able to understand the contents of the transmitted message. Because eavesdroppers may intercept the message, this necessarily requires that the message be somehow encrypted so that an intercepted message cannot be understood by an interceptor. This aspect of confidentiality is probably the most commonly perceived meaning of the term **secure communication**.
* **Message integrity**. Alice and Bob want to ensure that the content of their communication is not altered, either maliciously or by accident, in transit. Extensions to the checksumming techniques that we encountered in reliable transport and data link protocols can be used to provide such message integrity.
* **End-point authentication**. Both the sender and receiver should be able to confirm the identity of the other party involved in the communication -- to confirm that the other party is indeed who or what they claim to be. Face-to-face human communication solves this problem easily by visual recognition. When communicating entities exchange messages over a medium where they cannot see the other party, authentication is not so simple.
* **Operational security**. Almost all organizations (companies, universities, and so on) today have networks that are attached to the public Internet. These networks therefore can potentially be compromised. Attackers can attempt to deposit worms into the hosts in the network, obtain corporate secrets, map the internal network configurations, and launch DoS attacks. We'll see operational devices such as firewalls and intrusion detection systems are used to counter attacks against an organization's network. A firewall sits between the organization's network and the public network, controlling packet access to and from the network. An intrusion detection system performs "deep packet inspection," alerting the network administrators about suspicious activity.

## Cryptography

Cryptographic techniques are inextricably woven into authentication, message integrity, nonrepudiation, and more. Cryptographic techniques allow a sender to disguise data so that an intruder can gain no information from the intercepted data. The receiver, of course, must be able to recover the original data from the disguised data.

Suppose now that Alice wants to send a message to Bob. Alice's message in its original form (for example, "Bob, I love you. Alice") is known as **plaintext**, or **cleartext**. Alice encrypts her plaintext message using an encryption algorithm so that the encrypted message, known as **ciphertext**, looks unintelligible to any intruder. Interestingly, in many modern cryptographic systems, including those used in the Internet, the encryption technique itself is known -- published, standardized, and available to everyone (for example, [RFC 1321; RFC 3447; RFC 2420; NIST 2001]), even a potential intruder! Clearly, if everyone knows the method for encoding data, then there must be some secret information that prevents an intruder from decrypting the transmitted data. This is where keys come in. In **symmetric key systems**, Alice's and Bob's keys are identical and are secret. In **public key systems**, a pair of keys is used. One of the keys is known to both Bob and Alice (indeed, it is known to the whole world). The other key is known only by either Bob or Alice (but not both).

![cryptography](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/Cryptography_components.png?raw=true)

### Symmetric Key Cryptography

There are two broad classes of symmetric encryption techniques: **stream ciphers** and **block ciphers**. Now we focus on block ciphers, which are used in many secure Internet protocols, including **PGP (for secure e-mail)**, **SSL (for securing TCP connections)**, and **IPsec (for securing the network-layer transport)**. In a block cipher, the message to be encrypted is processed in blocks of k bits. For example, if k = 64, then the message is broken into 64-bit blocks, and each block is encrypted independently. To encode a block, the cipher uses a one-to-one mapping to map the k-bit block of cleartext to a k-bit block of ciphertext. Let's look at an example. Suppose that k = 3, so that the block cipher maps 3-bit inputs (clear-text) to 3-bit outputs (ciphertext). To make sure the security of the message the k is required to be big enough. However, this is not so easy to achieve. Suppose that k = 64, then both sender and reciever will need to maintain a table with $2^{64}$ input values, which is an infeasible task. Thus, a full-table block cipher, providing predetermined mappings between all inputs and outputs (as in the example above), is simply out of the question. **Instead, block ciphers typically use functions that simulate randomly permuted tables**. An example (adapted from [Kaufman 1995]) of such a function for k = 64 bits is shown in Figure 8.5. The function first breaks a 64-bit block into 8 chunks, with each chunk consisting of 8 bits. Each 8-bit chunk is processed by an 8-bit to 8-bit table, which is of manageable size. For example, the first chunk is processed by the table denoted by $T_1$. Next, the 8 output chunks are reassembled into a 64-bit block. The positions of the 64 bits in the block are then scrambled (permuted) to produce a 64-bit output. This output is fed back to the 64-bit input, where another cycle begins. After n such cycles, the function provides a 64-bit block of ciphertext. The purpose of the rounds is to make each input bit affect most (if not all) of the final output bits. (If only one round were used, a given input bit would affect only 8 of the 64 output bits.) The key for this block cipher algorithm would be the eight permutation tables (assuming the scramble function is publicly known). Today there are a number of popular block ciphers, including **DES (standing for Data Encryption Standard)**, **3DES**, and **AES (standing for Advanced Encryption Standard)**.

![block cipher](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/block_cipher.png?raw=true)

In computer networking applications, we typically need to encrypt long messages (or long streams of data). If we apply a block cipher as described by simply chopping up the message into k-bit blocks and independently encrypting each block, a subtle but important problem occurs. To see this, observe that two or more of the clear-text blocks can be identical. For example, the cleartext in two or more blocks could be "HTTP/1.1". For these identical blocks, a block cipher would, of course, produce the same ciphertext. An attacker could potentially guess the cleartext when it sees identical ciphertext blocks and may even be able to decrypt the entire message by identifying identical ciphtertext blocks and using knowledge about the underlying protocol structure. To address this problem, we can mix some randomness into the ciphertext so that identical plaintext blocks produce different ciphertext blocks.

### Public Key Encryption

The use of public key cryptography is conceptually quite simple. Suppose Alice wants to communicate with Bob. As shown in Figure 8.6, rather than Bob and Alice sharing a single secret key (as in the case of symmetric key systems), Bob (the recipient of Alice's messages) instead has two keys -- a **public key** that is available to everyone in the world (including Trudy the intruder) and a **private key** that is known only to Bob. We will use the notation $K_B^+$ and $K_B^-$ to refer to Bob's public and private keys, respectively. In order to communicate with Bob, Alice first fetches Bob's public key. Alice then encrypts her message, m, to Bob using Bob's public key and a known (for example, standardized) encryption algorithm; that is, Alice computes $K_B^+(m)$. Bob receives Alice's encrypted message and uses his private key and a known (for example, standardized) decryption algorithm to decrypt Alice's encrypted message. That is, Bob computes $K_B^- K_B^+(m)$. We will see below that there are encryption/decryption algorithms and techniques for choosing public and private keys such that $K_B^- K_B^+(m) = m$; that is, applying Bob's public key, $K_B^+$ , to a message, m (to get $K_B^+(m)$), and then applying Bob's private key, $K_B^-$ , to the encrypted version of m (that is, computing $K_B^- K_B^+(m)$) gives back m. This is a remarkable result! In this manner, Alice can use Bob's publicly available key to send a secret message to Bob without either of them having to distribute any secret keys! We will see shortly that we can interchange the public key and private key encryption and get the same remarkable result -- that is, $K_B^- K_B^+(m) = K_B^+ K_B^-(m) = m$.

![Public Key cryptography](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/Public_Key_cryptography.png?raw=true)

While there may be many algorithms that address these concerns, the **RSA algorithm** (named after its founders, Ron Rivest, Adi Shamir, and Leonard Adleman) has become almost synonymous with public key cryptography. Let's first see how RSA works and then examine why it works. RSA makes extensive use of arithmetic operations using modulo-n arithmetic. Adding and multiplying with modular arithmetic is facilitated with the following handy facts:

* [(a mod n) + (b mod n)] mod n = (a + b) mod n
* [(a mod n) – (b mod n)] mod n = (a – b) mod n
* [(a mod n) * (b mod n)] mod n = (a * b) mod n

Now suppose that Alice wants to send to Bob an RSA-encrypted message, as shown in Figure 8.6. In our discussion of RSA, let's always keep in mind that a message is nothing but a bit pattern, and every bit pattern can be uniquely represented by an integer number (along with the length of the bit pattern). For example, suppose a message is the bit pattern 1001; this message can be represented by the decimal integer 9. Thus, when encrypting a message with RSA, it is equivalent to encrypting the unique integer number that represents the message. There are two interrelated components of RSA:

* The choice of the public key and the private key
* The encryption and decryption algorithm

## Message Integrity and Digital Signatures

### Cryptography Hash Functions

As shown in Figure 8.7, a hash function takes an input, m, and computes a fixed-size string H(m) known as a hash. The Internet checksum and CRCs meet this definition. A cryptographic hash function is required to have the following additional property:

* It is computationally infeasible to find any two different messages x and y such that H(x) = H(y).

![hash function](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/Cryptography_hash_functions.png?raw=true)

The **MD5 hash algorithm** of Ron Rivest [RFC 1321] is in wide use today. It computes a 128-bit hash in a four-step process. For a description of MD5 (including a C source code implementation) see [RFC 1321]. The second major hash algorithm in use today is the Secure Hash Algorithm (SHA-1) [FIPS 1995]. It produces a 160-bit message digest. The longer output length makes SHA-1 more secure.

### Message Authentication Code

let's take a first stab at how we might perform message integrity:

1. Alice creates message m and calculates the hash H(m) (for example with SHA-1).
2. Alice then appends H(m) to the message m, creating an extended message (m, H(m)), and sends the extended message to Bob.
3. Bob receives an extended message (m, h) and calculates H(m). If H(m) = h, Bob concludes that everything is fine.

This approach is obviously flawed. Trudy can create a bogus message m' in which she says she is Alice, calculate H(m'), and send Bob (m', H(m')). When Bob receives the message, everything checks out in step 3, so Bob doesn't suspect any funny business. To perform message integrity, in addition to using cryptographic hash functions, Alice and Bob will need a shared secret s. This shared secret, which is nothing more than a string of bits, is called the **authentication key**. Using this shared secret, message integrity can be performed as follows:

1. Alice creates message m, concatenates s with m to create m + s, and calculates the hash H(m + s) (for example with SHA-1). H(m + s) is called the **message authentication code (MAC)**.
2. Alice then appends the MAC to the message m, creating an extended message (m, H(m + s)), and sends the extended message to Bob.
3. Bob receives an extended message (m, h) and knowing s, calculates the MAC H(m + s). If H(m + s) = h, Bob concludes that everything is fine.

![MAC](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/MAC.png?raw=true)

One nice feature of a MAC is that it does not require an encryption algorithm. Indeed, in many applications, including the link-state routing algorithm described earlier, communicating entities are only concerned with message integrity and are not concerned with message confidentiality. Using a MAC, the entities can authenticate the messages they send to each other without having to integrate complex encryption algorithms into the integrity process.

### Digital Signatures

In a digital world, one often wants to indicate the owner or creator of a document, or to signify one's agreement with a document's content. A **digital signature** is a cryptographic technique for achieving these goals in a digital world. Just as with handwritten signatures, digital signing should be done in a way that is verifiable and nonforgeable. That is, it must be possible to prove that a document signed by an individual was indeed signed by that individual (the signature must be verifiable) and that only that individual could have signed the document (the signature cannot be forged). Recall that with public-key cryptography, Bob has both a public and private key, with both of these keys as a tuple is unique to Bob. Thus, public-key cryptography is an excellent candidate for providing digital signatures.

One concern with signing data by encryption is that encryption and decryption are computationally expensive. Given the overheads of encryption and decryption, signing data via complete encryption/decryption can be overkill. A more efficient approach is to introduce hash functions into the digital signature. Using a hash function, Bob signs the hash of a message rather than the message itself.

In the context of Bob sending a message to Alice, Figure 8.11 provides a summary of the operational procedure of creating a digital signature. Bob puts his original long message through a hash function. He then digitally signs the resulting hash with his private key. The original message (in cleartext) along with the digitally signed message digest (henceforth referred to as the digital signature) is then sent to Alice. Figure 8.12 provides a summary of the operational procedure of the signature. Alice applies the sender's public key to the message to obtain a hash result. Alice also applies the hash function to the cleartext message to obtain a second hash result. If the two hashes match, then Alice can be sure about the integrity and author of the message.

![sender](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/signed_sender.png?raw=true)

![receiver](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/signed_receiver.png?raw=true)

An important application of digital signatures is **public key certification**, that is, certifying that a public key belongs to a specific entity. Public key certification is used in many popular secure networking protocols, including **IPsec** and **SSL**.

As the following figure shows, if an intruder Trudy masquerades her public key as Bob's public key and sends the encrypted hash code with her private key to Alice, Alice will find that the encrypted hash code matches "Bob's public key" and she will think that it is Bob sent her the meeage.

![masquerades public key cryptography](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/masquerades_public_key.png?raw=true)

As the above example shows, for public key cryptography to be useful, you need to be able to verify that you have the actual public key of the entity (person, router, browser, and so on) with whom you want to communicate. For example, when Alice wants to communicate with Bob using public key cryptography, she needs to verify that the public key that is supposed to be Bob's is indeed Bob's. Binding a public key to a particular entity is typically done by a **Certification Authority (CA)**, whose job is to validate identities and issue certificates. A CA has the following roles:

1. **A CA verifies that an entity (a person, a router, and so on) is who it says it is.** There are no mandated procedures for how certification is done. When dealing with a CA, one must trust the CA to have performed a suitably rigorous identity verification. For example, if Trudy were able to walk into the Fly-by-Night CA and simply announce "I am Alice" and receive certificates associated with the identity of Alice, then one shouldn't put much faith in public keys certified by the Fly-by-Night CA. On the other hand, one might (or might not!) be more willing to trust a CA that is part of a federal or state program. You can trust the identity associated with a public key only to the extent to which you can trust a CA and its identity verification techniques. What a tangled web of trust we spin!
2. Once the CA verifies the identity of the entity, the CA creates a certificate that binds the public key of the entity to the identity. The certificate contains the public key and globally unique identifying information about the owner of the public key (for example, a human name or an IP address). The certificate is digitally signed by the CA.

## End-Point Authentication

**End-point authentication** is the process of one entity proving its identity to another entity over a computer network, for example, a user proving its identity to an email server.

## Securing E-Mail

To overcome the efficiency problem for e-mail confidentiality, let's make use of a session key. In particular, Alice (1) selects a random symmetric session key, $K_S$, (2) encrypts her message, m, with the symmetric key, (3) encrypts the symmetric key with Bob's public key, $K_B^+$, (4) concatenates the encrypted message and the encrypted symmetric key to form a "package" and (5) sends the package to Bob's e-mail address. The steps are illustrated in Figure 8.19. (In this and the subsequent figures, the circled "+" represents concatenation and the circled "–" represents deconcatenation.) When Bob receives the package, he (1)uses his private key, $K_B^–$, to obtain the symmetric key, $K_S$, and (2) uses the symmetric key $K_S$ to decrypt the message m.

![e-mail confidentiality](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/email_confidentiality.png?raw=true)

Having designed a secure e-mail system that provides confidentiality, let's now design another system that provides both sender authentication and message integrity. We'll suppose, for the moment, that Alice and Bob are no longer concerned with confidentiality, and are concerned only about sender authentication and message integrity. To accomplish this task, we use digital signatures and message digests. Specifically, Alice (1) applies a hash function, H (for example, MD5), to her message, m, to obtain a message digest, (2) signs the result of the hash function with her private key, $K_A^-$ , to create a digital signature, (3) concatenates the original (unencrypted) message with the signature to create a package, and (4) sends the package to Bob's e-mail address. When Bob receives the package, he (1) applies Alice's public key, $K_A^+$ , to the signed message digest and (2) compares the result of this operation with his own hash, H, of the message. The steps are illustrated in Figure 8.20. If the two results are the same, Bob can be pretty confident that the message came from Alice and is unaltered.

![email authentication and message integrity](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/email_authentication.png?raw=true)

Now let's consider designing an e-mail system that provides confidentiality, sender authentication, and message integrity. This can be done by combining the procedures in Figures 8.19 and 8.20. Alice first creates a preliminary package, exactly as in Figure 8.20, that consists of her original message along with a digitally signed hash of the message. She then treats this preliminary package as a message in itself and sends this new message through the sender steps in Figure 8.19, creating a new package that is sent to Bob. The steps applied by Alice are shown in Figure 8.21. When Bob receives the package, he first applies his side of Figure 8.19 and then his side of Figure 8.20. It should be clear that this design achieves the goal of providing confidentiality, sender authentication, and message integrity. Note that, in this scheme, Alice uses public key cryptography twice: once with her own private key and once with Bob's public key. Similarly, Bob also uses public key cryptography twice -- once with his private key and once with Alice's public key. The secure e-mail design outlined in Figure 8.21 probably provides satisfactory security for most e-mail users for most occasions. But there is still one important issue that remains to be addressed. The design in Figure 8.21 requires Alice to obtain Bob's public key, and requires Bob to obtain Alice's public key. The distribution of these public keys is a nontrivial problem. For example, Trudy might masquerade as Bob and give Alice her own public key while saying that it is Bob's public key, enabling her to receive the message meant for Bob. A popular approach for securely distributing public keys is to certify the public keys using a CA.

![email security](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/email_security.png?raw=true)

## Secure Sockets Layer (SSL) and Transport Layer Security (TLS)

We'll drop down a layer in the protocol stack and examine how cryptography can enhance TCP with security services, including confidentiality, data integrity, and end-point authentication. This enhanced version of TCP is commonly known as **Secure Sockets Layer (SSL)**. A slightly modified version of SSL version 3, called **Transport Layer Security (TLS)**, has been standardized by the IETF [RFC 4346]. SSL is supported by all popular Web browsers and Web servers, and it is used by essentially all Internet commerce sites (including Amazon, eBay, Yahoo!, MSN, and so on). Tens of billions of dollars are spent over SSL every year. In fact, if you have ever purchased anything over the Internet with your credit card, the communication between your browser and the server for this purchase almost certainly went over SSL. (You can identify that SSL is being used by your browser when the URL begins with https: rather than http.)

SSL is often used to provide security to transactions that take place over HTTP. However, because SSL secures TCP, it can be employed by any application that runs over TCP. SSL provides a simple Application Programmer Interface (API) with sockets, which is similar and analogous to TCP's API. When an application wants to employ SSL, the application includes SSL classes/libraries. As shown in Figure 8.24, although SSL technically resides in the application layer, from the developer's perspective it is a transport protocol that provides TCP's services enhanced with security services.

![SSL](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/SSL.png?raw=true)

SSL has three phases: **handshake**, **key derivation**, and **data transfer**. We now describe these three phases for a communication session between a client (Bob) and a server (Alice), with Alice having a private/public key pair and a certificate that binds her identity to her public key.

During the handshake phase, Bob needs to (a) establish a TCP connection with Alice, (b) verify that Alice is really Alice, and (c) send Alice a master secret key, which will be used by both Alice and Bob to generate all the symmetric keys they need for the SSL session. These three steps are shown in Figure 8.25. Note that once the TCP connection is established, Bob sends Alice a hello message. Alice then responds with her certificate, which contains her public key. Because the certificate has been certified by a CA, Bob knows for sure that the public key in the certificate belongs to Alice. Bob then generates a **Master Secret (MS)** (which will only be used for this SSL session), encrypts the MS with Alice's public key to create the **Encyrpted Master Secret (EMS)**, and sends the EMS to Alice. Alice decrypts the EMS with her private key to get the MS. After this phase, both Bob and Alice (and no one else) know the master secret for this SSL session.

![SSL handshake](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/SSL_handshake.png?raw=true)

In principle, the MS, now shared by Bob and Alice, could be used as the symmetric session key for all subsequent encryption and data integrity checking. It is, however, generally considered safer for Alice and Bob to each use different cryptographic keys, and also to use different keys for encryption and integrity checking. Thus, both Alice and Bob use the MS to generate four keys:

* $E_B$ = session encryption key for data sent from Bob to Alice
* $M_B$ = session MAC key for data sent from Bob to Alice
* $E_A$ = session encryption key for data sent from Alice to Bob
* $M_A$ = session MAC key for data sent from Alice to Bob

Alice and Bob each generate the four keys from the MS. This could be done by simply slicing the MS into four keys. (But in real SSL it is a little more complicated, as we'll see.) At the end of the key derivation phase, both Alice and Bob have all four keys. **The two encryption keys will be used to encrypt data; the two MAC keys will be used to verify the integrity of the data**.

Now that Alice and Bob share the same four session keys ($E_B$, $M_B$, $E_A$, and $M_A$), they can start to send secured data to each other over the TCP connection. Since TCP is a byte-stream protocol, a natural approach would be for SSL to encrypt application data on the fly and then pass the encrypted data on the fly to TCP. But if we were to do this, where would we put the MAC for the integrity check? We certainly do not want to wait until the end of the TCP session to verify the integrity of all of Bob's data that was sent over the entire session! To address this issue, SSL breaks the data stream into **records**, appends a MAC to each record for integrity checking, and then encrypts the record+MAC. To create the MAC, Bob inputs the record data along with the key $M_B$ into a hash function. To encrypt the package record+MAC, Bob uses his session encryption key $E_B$. This encrypted package is then passed to TCP for transport over the Internet.

## IPsec and Virtual Private Networks (VPNs)

The IP security protocol, more commonly known as **IPsec**, provides security at the network layer. IPsec secures IP datagrams between any two network-layer entities, including hosts and routers. Many institutions (corporations, government branches, non-profit organizations, and so on) use IPsec to create **virtual private networks (VPNs)** that run over the public Internet. In addition to confidentiality, a network-layer security protocol could potentially provide other security services. For example, it could provide source authentication, so that the receiving entity can verify the source of the secured datagram. A network-layer security protocol could provide data integrity, so that the receiving entity can check for any tampering of the datagram that may have occurred while the datagram was in transit. A network-layer security service could also provide replay-attack prevention, meaning that Bob could detect any duplicate datagrams that an attacker might insert. We will soon see that IPsec indeed provides mechanisms for all these security services, that is, for confidentiality, source authentication, data integrity, and replay-attack prevention.

An institution that extends over multiple geographical regions often desires its own IP network, so that its hosts and servers can send data to each other in a secure and confidential manner. To achieve this goal, the institution could actually deploy a stand-alone physical network -- including routers, links, and a DNS infrastructure -- that is completely separate from the public Internet. Such a disjoint network, dedicated to a particular institution, is called a **private network**. Not surprisingly, a private network can be very costly, as the institution needs to purchase, install, and maintain its own physical network infrastructure. Instead of deploying and maintaining a private network, many institutions today create VPNs over the existing public Internet. With a VPN, the institution's inter-office traffic is sent over the public Internet rather than over a physically independent network. But to provide confidentiality, the inter-office traffic is encrypted before it enters the public Internet. A simple example of a VPN is shown in Figure 8.27. Here the institution consists of a headquarters, a branch office, and traveling salespersons that typically access the Internet from their hotel rooms. (There is only one salesperson shown in the figure.) In this VPN, whenever two hosts within headquarters send IP datagrams to each other or whenever two hosts within the branch office want to communicate, they use good-old vanilla IPv4 (that is, without IPsec services). However, when two of the institution's hosts communicate over a path that traverses the public Internet, the traffic is encrypted before it enters the Internet. To get a feel for how a VPN works, let's walk through a simple example in the context of Figure 8.27. When a host in headquarters sends an IP datagram to a salesperson in a hotel, the gateway router in headquarters converts the vanilla IPv4 datagram into an IPsec datagram and then forwards this IPsec datagram into the Internet. This IPsec datagram actually has a traditional IPv4 header, so that the routers in the public Internet process the datagram as if it were an ordinary IPv4 datagram to them, the datagram is a perfectly ordinary datagram. But, as shown Figure 8.27, the payload of the IPsec datagram includes an IPsec header, which is used for IPsec processing; furthermore, the payload of the IPsec datagram is encrypted. When the IPsec datagram arrives at the salesperson's laptop, the OS in the laptop decrypts the payload (and provides other security services, such as verifying data integrity) and passes the unencrypted payload to the upper-layer protocol (for example, to TCP or UDP).

![VPN](https://github.com/SaltyFish123/SaltyFish123.github.io/blob/master/assets/images/computer_network/VPN.png?raw=true)

In the IPsec protocol suite, there are two principal protocols: the **Authentication Header (AH)** protocol and the **Encapsulation Security Payload (ESP)** protocol.

## Firewalls

A firewall is a combination of hardware and software that isolates an organization's internal network from the Internet at large, allowing some packets to pass and blocking others. Firewalls can be classified in three categories: **traditional packet filters**, **stateful filters**, and **application gateways**.

For **traditional packet filters**, an organization typically has a gateway router connecting its internal network to its ISP (and hence to the larger public Internet). All traffic leaving and entering the internal network passes through this router, and it is at this router where **packet filtering** occurs. A packet filter examines each datagram in isolation, determining whether the datagram should be allowed to pass or should be dropped based on administrator-specific rules. Filtering decisions are typically based on:

* IP source or destination address
* Protocol type in IP datagram field: TCP, UDP, ICMP, OSPF, and so on
* TCP or UDP source and destination port
* TCP flag bits: SYN, ACK, and so on
* ICMP message type
* Different rules for datagrams leaving and entering the network
* Different rules for the different router interfaces

A filtering policy can be based on a combination of addresses and port numbers. For example, a filtering router could forward all Telnet datagrams (those with a port number of 23) except those going to and coming from a list of specific IP addresses. This policy permits Telnet connections to and from hosts on the allowed list. Unfortunately, basing the policy on external addresses provides no protection against datagrams that have had their source addresses spoofed. Filtering can also be based on whether or not the TCP ACK bit is set. This trick is quite useful if an organization wants to let its internal clients connect to external servers but wants to prevent external clients from connecting to internal servers. The first segment in every TCP connection has the ACK bit set to 0, whereas all the other segments in the connection have the ACK bit set to 1. Thus, if an organization wants to prevent external clients from initiating connections to internal servers, it simply filters all incoming segments with the ACK bit set to 0. This policy kills all TCP connections originating from the outside, but permits connections originating internally. Firewall rules are implemented in routers with access control lists, with each router interface having its own list.

For **stateful packet filters**, it track TCP connections, and use this knowledge to make filtering decisions rather than making filtering decisions on each packet in isolation as the traditional packet filter. Stateful filters track all ongoing TCP connections in a connection table. This is possible because the firewall can observe the beginning of a new connection by observing a three-way handshake (SYN, SYNACK, and ACK); and it can observe the end of a connection when it sees a FIN packet for the connection. The firewall can also (conservatively) assume that the connection is over when it hasn't seen any activity over the connection for, say, 60 seconds. Suppose that an internal user wants to surf an external Web site. Because this user first sends a TCP SYN segment, the user's TCP connection gets recorded in the connection table. When the Web server sends back packets (with the ACK bit necessarily set), the firewall checks the table and sees that a corresponding connection is in progress. The firewall will thus let these packets pass, thereby not interfering with the internal user's Web surfing activity.

For **application gateway**, an application gateway is an application-specific server through which all application data (inbound and outbound) must pass. Multiple application gateways can run on the same host, but each gateway is a separate server with its own processes. Let's design a firewall that allows only a restricted set of internal users to Telnet outside and prevents all external clients from Telneting inside. Such a policy can be accomplished by implementing a combination of a packet filter (in a router) and a Telnet application gateway. The router's filter is configured to block all Telnet connections except those that originate from the IP address of the application gateway. Such a filter configuration forces all outbound Telnet connections to pass through the application gateway. Consider now an internal user who wants to Telnet to the outside world. The user must first set up a Telnet session with the application gateway. An application running in the gateway, which listens for incoming Telnet sessions, prompts the user for a user ID and password. When the user supplies this information, the application gateway checks to see if the user has permission to Telnet to the outside world. If not, the Telnet connection from the internal user to the gateway is terminated by the gateway. If the user has permission, then the gateway (1) prompts the user for the host name of the external host to which the user wants to connect, (2) sets up a Telnet session between the gateway and the external host, and (3) relays to the external host all data arriving from the user, and relays to the user all data arriving from the external host. Thus, the Telnet application gateway not only performs user authorization but also acts as a Telnet server and a Telnet client, relaying information between the user and the remote Telnet server.
